<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Breakout</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #0b0b0b; }
    canvas { display: block; touch-action: none; }
    
    /* Start Screen Overlay */
    #startOverlay {
      display: flex;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(11, 11, 11, 0.95);
      z-index: 100;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Courier New', monospace;
      color: #6cff00;
      cursor: pointer;
    }
    #startOverlay.hidden { display: none; }
    #startOverlay h1 {
      font-size: 3rem;
      text-transform: uppercase;
      letter-spacing: 0.3rem;
      margin-bottom: 2rem;
      text-shadow: 0 0 20px #6cff00, 0 0 40px #6cff00;
      animation: pulse 1.5s ease-in-out infinite;
    }
    #startOverlay .click-text {
      font-size: 1.5rem;
      animation: blink 1s step-end infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    
    /* Difficulty Selection Overlay */
    #difficultyOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(11, 11, 11, 0.95);
      z-index: 100;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Courier New', monospace;
      color: #6cff00;
    }
    #difficultyOverlay.show { display: flex; }
    #difficultyOverlay h2 {
      font-size: 2rem;
      margin-bottom: 2rem;
      text-shadow: 0 0 15px #6cff00;
    }
    .diff-btn {
      background: #0b0b0b;
      border: 2px solid #6cff00;
      color: #6cff00;
      padding: 1rem 3rem;
      font-size: 1.2rem;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      margin: 0.5rem;
      min-width: 200px;
      transition: all 0.2s;
    }
    .diff-btn:hover {
      background: #6cff00;
      color: #0b0b0b;
    }
    .diff-desc {
      font-size: 0.8rem;
      color: #4a9900;
      margin-top: 0.3rem;
    }
    
    /* Game Over Overlay */
    #gameOverOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(11, 11, 11, 0.95);
      z-index: 100;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      color: #6cff00;
    }
    #gameOverOverlay.show { display: flex; }
    #gameOverOverlay h1 { font-size: 2.5rem; margin-bottom: 1rem; }
    #gameOverOverlay .final-score { font-size: 1.5rem; margin-bottom: 1.5rem; }
    #gameOverOverlay input {
      background: #0b0b0b;
      border: 2px solid #6cff00;
      color: #6cff00;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      width: 200px;
      text-align: center;
      margin-bottom: 1rem;
    }
    #gameOverOverlay input::placeholder { color: #3a7a00; }
    #gameOverOverlay button {
      background: #6cff00;
      color: #0b0b0b;
      border: none;
      padding: 0.75rem 2rem;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 2rem;
    }
    #gameOverOverlay button:hover { background: #5de000; }
    
    /* Level Complete Overlay */
    #levelOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(11, 11, 11, 0.95);
      z-index: 100;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Courier New', monospace;
      color: #6cff00;
      cursor: pointer;
    }
    #levelOverlay.show { display: flex; }
    #levelOverlay h1 {
      font-size: 2.5rem;
      text-transform: uppercase;
      letter-spacing: 0.2rem;
      margin-bottom: 1rem;
      text-shadow: 0 0 20px #6cff00, 0 0 40px #6cff00;
    }
    #levelOverlay .level-info {
      font-size: 1.5rem;
      margin-bottom: 2rem;
    }
    #levelOverlay .click-text {
      font-size: 1.2rem;
      animation: blink 1s step-end infinite;
    }
    
    /* Leaderboard */
    #leaderboard {
      background: #0b0b0b;
      border: 2px solid #6cff00;
      padding: 1rem 1.5rem;
      max-width: 280px;
      width: 90%;
    }
    #leaderboard h2 { font-size: 1.2rem; margin-bottom: 0.75rem; text-align: center; }
    #leaderboard ol {
      list-style-position: inside;
      padding: 0;
    }
    #leaderboard li {
      display: flex;
      justify-content: space-between;
      padding: 0.3rem 0;
      border-bottom: 1px solid #1a3300;
    }
    #leaderboard li:last-child { border-bottom: none; }
    #leaderboard .name { flex: 1; overflow: hidden; text-overflow: ellipsis; }
    #leaderboard .score-val { font-weight: bold; margin-left: 1rem; }
  </style>
</head>
<body>
<div id="startOverlay">
  <h1>Breakout</h1>
  <div class="click-text">Click to Start</div>
</div>

<div id="difficultyOverlay">
  <h2>Select Difficulty</h2>
  <button class="diff-btn" data-diff="easy">EASY<div class="diff-desc">Fewer bricks</div></button>
  <button class="diff-btn" data-diff="normal">NORMAL<div class="diff-desc">Standard layout</div></button>
  <button class="diff-btn" data-diff="hard">HARD<div class="diff-desc">Bricks move down!</div></button>
</div>

<canvas id="game"></canvas>

<div id="levelOverlay">
  <h1 id="levelTitle">Level Complete!</h1>
  <div class="level-info">Score: <span id="levelScore">0</span></div>
  <div class="click-text">Click to Continue</div>
</div>

<div id="gameOverOverlay">
  <h1 id="gameOverTitle">Game Over</h1>
  <div class="final-score">Score: <span id="finalScore">0</span></div>
  <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
  <button id="submitScore">Save & Play Again</button>
  <div id="leaderboard">
    <h2>üèÜ Top 10 High Scores</h2>
    <ol id="highScoreList"></ol>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ACCENT = '#6cff00';
const BG = '#0b0b0b';

// Mobile detection
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                 ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

let W, H, scale;
let paddleW, paddleH, paddleX, paddleY, basePaddleW;
let ballR, baseBallR;
let brickRows, brickCols, brickW, brickH, brickPad, brickOffsetTop, brickOffsetLeft;
let bricks = [];

// Level system
let currentLevel = 1;
const MAX_LEVEL = 5;
let levelTransition = false;

// Difficulty system
let selectedDifficulty = 'normal';
const DIFFICULTY_BRICK_MULT = { easy: 0.7, normal: 1.0, hard: 1.0 };
let brickMoveTimer = 0;
const BRICK_MOVE_INTERVAL = 5000; // 5 seconds for hard mode
const BRICK_MOVE_AMOUNT = 0.5; // multiplied by scale

// Level configurations
const LEVEL_CONFIGS = {
  1: { rows: 3, cols: 6, speedMult: 1.0, paddleMult: 1.0, pattern: 'simple' },
  2: { rows: 4, cols: 7, speedMult: 1.2, paddleMult: 1.0, pattern: 'simple' },
  3: { rows: 5, cols: 8, speedMult: 1.4, paddleMult: 1.0, pattern: 'checkerboard' },
  4: { rows: 6, cols: 8, speedMult: 1.6, paddleMult: 0.75, pattern: 'pyramid' },
  5: { rows: 7, cols: 8, speedMult: 1.9, paddleMult: 0.6, pattern: 'fortress' }
};

let score = 0, lives = 3, gameOver = false, won = false;
let gameStarted = false;
let ballSticky = true;
let baseSpeed;

// Multi-ball support
let balls = [];

// Power-up system
const POWERUP_TYPES = {
  MULTI_BALL: { color: '#ff6b6b', duration: 0 },
  LASER: { color: '#ff00ff', duration: 8000 },
  BIG_BALL: { color: '#00ffff', duration: 10000 },
  SMALL_BALL: { color: '#ff8800', duration: 10000 },
  WIDE_PADDLE: { color: '#00ff88', duration: 10000 },
  NARROW_PADDLE: { color: '#ff4444', duration: 10000 }
};

const POWERUP_SVG_PATH = new Path2D('M38.7837 0C17.3672 0 0 17.3672 0 38.7837C0 60.2003 17.3672 77.5675 38.7837 77.5675C60.2062 77.5675 77.5675 60.2003 77.5675 38.7837C77.5675 17.3612 60.2062 0 38.7837 0ZM35.4766 65.8469L23.9934 66.8859L24.1359 50.2372L35.5894 52.4222L35.4766 65.8469ZM50.8072 64.4575L39.3241 65.4966L39.4309 53.2356L50.8844 55.5334L50.8072 64.4575ZM61.7975 52.6834L21.9984 44.8341C16.0609 42.9103 11.3109 39.5022 11.3822 31.4034C11.5009 17.5394 23.2037 10.5212 35.3519 9.42281C48.1591 8.265 59.4403 12.1956 59.8144 26.7662L42.6253 28.3219C42.9756 26.0241 41.9959 24.5991 40.5175 23.7262C39.0391 22.7703 36.9787 22.5387 35.1559 22.6991C32.6741 22.9247 28.6187 23.9637 28.595 27.3244C28.8919 31.5816 37.3112 31.7419 45.6356 33.3391C53.9659 34.9362 62.1953 38.1366 62.1003 49.1387C62.0884 50.3797 61.9816 51.5553 61.7975 52.6834Z');

let powerups = [];
let activePowerups = {};
let lasers = [];
let laserActive = false;

// High Score Functions
function getHighScores() {
  const data = localStorage.getItem('breakoutHighScores');
  return data ? JSON.parse(data) : [];
}

function saveHighScore(name, playerScore) {
  const scores = getHighScores();
  scores.push({ name: name || 'Anonymous', score: playerScore });
  scores.sort((a, b) => b.score - a.score);
  const top10 = scores.slice(0, 10);
  localStorage.setItem('breakoutHighScores', JSON.stringify(top10));
  return top10;
}

function renderLeaderboard() {
  const scores = getHighScores();
  const list = document.getElementById('highScoreList');
  if (scores.length === 0) {
    list.innerHTML = '<li style="justify-content:center;">No scores yet!</li>';
  } else {
    list.innerHTML = scores.map((s, i) => 
      `<li><span class="name">${i + 1}. ${s.name}</span><span class="score-val">${s.score}</span></li>`
    ).join('');
  }
}

function showGameOverScreen() {
  document.getElementById('gameOverTitle').textContent = won ? 'üéâ You Win!' : 'Game Over';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('playerName').value = '';
  renderLeaderboard();
  document.getElementById('gameOverOverlay').classList.add('show');
  document.getElementById('playerName').focus();
}

function hideGameOverScreen() {
  document.getElementById('gameOverOverlay').classList.remove('show');
}

function showLevelComplete() {
  levelTransition = true;
  if (currentLevel >= MAX_LEVEL) {
    won = true;
    gameOver = true;
    showGameOverScreen();
  } else {
    document.getElementById('levelTitle').textContent = 'Level ' + currentLevel + ' Complete!';
    document.getElementById('levelScore').textContent = score;
    document.getElementById('levelOverlay').classList.add('show');
  }
}

function hideLevelOverlay() {
  document.getElementById('levelOverlay').classList.remove('show');
  levelTransition = false;
}

function showDifficultyScreen() {
  document.getElementById('difficultyOverlay').classList.add('show');
}

function hideDifficultyScreen() {
  document.getElementById('difficultyOverlay').classList.remove('show');
}

document.getElementById('levelOverlay').addEventListener('click', () => {
  hideLevelOverlay();
  currentLevel++;
  initLevel();
});

document.getElementById('submitScore').addEventListener('click', () => {
  const name = document.getElementById('playerName').value.trim();
  saveHighScore(name, score);
  hideGameOverScreen();
  showDifficultyScreen();
});

document.getElementById('playerName').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') document.getElementById('submitScore').click();
});

document.getElementById('startOverlay').addEventListener('click', () => {
  document.getElementById('startOverlay').classList.add('hidden');
  showDifficultyScreen();
});

document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    selectedDifficulty = btn.dataset.diff;
    hideDifficultyScreen();
    gameStarted = true;
    currentLevel = 1;
    score = 0;
    lives = 3;
    initGame();
  });
});

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  
  canvas.width = W;
  canvas.height = H;
  canvas.style.position = 'absolute';
  canvas.style.left = '0';
  canvas.style.top = '0';
  
  scale = Math.min(W / 480, H / 640);
  basePaddleW = 80 * scale;
  paddleH = 12 * scale;
  paddleY = H - 40 * scale;
  baseBallR = 8 * scale;
  ballR = baseBallR;
  brickPad = 6 * scale;
  brickOffsetTop = 50 * scale;
  brickOffsetLeft = 20 * scale;
  brickH = 18 * scale;
  baseSpeed = 4 * scale;
  
  // Recalculate brick width if game is active
  if (brickCols > 0) {
    brickW = (W - brickOffsetLeft * 2 - brickPad * (brickCols - 1)) / brickCols;
  }
}

function createBall(x, y, dx, dy) {
  return { x, y, dx, dy, sticky: false };
}

function generateBrickPattern(rows, cols, pattern) {
  const grid = [];
  for (let r = 0; r < rows; r++) {
    grid[r] = [];
    for (let c = 0; c < cols; c++) {
      let alive = true;
      switch(pattern) {
        case 'checkerboard':
          alive = (r + c) % 2 === 0;
          break;
        case 'pyramid':
          const mid = Math.floor(cols / 2);
          const dist = Math.abs(c - mid + 0.5);
          alive = dist <= (rows - r);
          break;
        case 'fortress':
          if (r === 0 || r === rows - 1 || c === 0 || c === cols - 1) {
            alive = true;
          } else if (r === 2 && c > 1 && c < cols - 2) {
            alive = true;
          } else if (r > 2 && r < rows - 2 && (c === 2 || c === cols - 3)) {
            alive = true;
          } else {
            alive = (r + c) % 3 === 0;
          }
          break;
        default:
          alive = true;
      }
      grid[r][c] = { x: 0, y: 0, alive, baseY: 0 };
    }
  }
  return grid;
}

function countAliveBricks() {
  let count = 0;
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      if (bricks[r] && bricks[r][c] && bricks[r][c].alive) count++;
    }
  }
  return count;
}

function initLevel() {
  resize();
  const config = LEVEL_CONFIGS[currentLevel];
  
  // Apply difficulty multiplier to rows/cols for easy mode
  const mult = DIFFICULTY_BRICK_MULT[selectedDifficulty];
  brickRows = Math.max(2, Math.round(config.rows * mult));
  brickCols = Math.max(4, Math.round(config.cols * mult));
  
  brickW = (W - brickOffsetLeft * 2 - brickPad * (brickCols - 1)) / brickCols;
  
  paddleW = basePaddleW * config.paddleMult;
  paddleX = (W - paddleW) / 2;
  ballR = baseBallR;
  
  const speed = baseSpeed * config.speedMult;
  ballSticky = true;
  balls = [createBall(paddleX + paddleW / 2, paddleY - ballR - 2, 3 * scale * (Math.random() > 0.5 ? 1 : -1), -speed)];
  balls[0].sticky = true;
  
  powerups = [];
  activePowerups = {};
  lasers = [];
  laserActive = false;
  brickMoveTimer = Date.now();
  
  bricks = generateBrickPattern(brickRows, brickCols, config.pattern);
  
  // Store base Y positions for hard mode
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      bricks[r][c].baseY = brickOffsetTop + r * (brickH + brickPad);
    }
  }
}

function initGame() {
  gameOver = false;
  won = false;
  currentLevel = 1;
  score = 0;
  lives = 3;
  initLevel();
}

function launchBall() {
  if (ballSticky && balls.length > 0 && balls[0].sticky) {
    balls[0].sticky = false;
    ballSticky = false;
  }
}

function spawnPowerup(x, y) {
  if (Math.random() > 0.25) return;
  const types = Object.keys(POWERUP_TYPES);
  const type = types[Math.floor(Math.random() * types.length)];
  powerups.push({ x, y, type, size: 24 * scale, speed: 2 * scale });
}

function activatePowerup(type) {
  const now = Date.now();
  const config = POWERUP_TYPES[type];
  const levelConfig = LEVEL_CONFIGS[currentLevel];
  
  switch(type) {
    case 'MULTI_BALL':
      if (balls.length > 0) {
        const b = balls[0];
        balls.push(createBall(b.x, b.y, -3 * scale, -baseSpeed * levelConfig.speedMult));
        balls.push(createBall(b.x, b.y, 3 * scale, -baseSpeed * levelConfig.speedMult));
      }
      break;
    case 'LASER':
      laserActive = true;
      activePowerups.LASER = now + config.duration;
      break;
    case 'BIG_BALL':
      ballR = baseBallR * 1.8;
      activePowerups.BIG_BALL = now + config.duration;
      delete activePowerups.SMALL_BALL;
      break;
    case 'SMALL_BALL':
      ballR = baseBallR * 0.5;
      activePowerups.SMALL_BALL = now + config.duration;
      delete activePowerups.BIG_BALL;
      break;
    case 'WIDE_PADDLE':
      paddleW = basePaddleW * LEVEL_CONFIGS[currentLevel].paddleMult * 1.5;
      activePowerups.WIDE_PADDLE = now + config.duration;
      delete activePowerups.NARROW_PADDLE;
      break;
    case 'NARROW_PADDLE':
      paddleW = basePaddleW * LEVEL_CONFIGS[currentLevel].paddleMult * 0.6;
      activePowerups.NARROW_PADDLE = now + config.duration;
      delete activePowerups.WIDE_PADDLE;
      break;
  }
}

function updatePowerups() {
  const now = Date.now();
  const levelConfig = LEVEL_CONFIGS[currentLevel];
  
  if (activePowerups.LASER && now > activePowerups.LASER) {
    laserActive = false;
    delete activePowerups.LASER;
  }
  if (activePowerups.BIG_BALL && now > activePowerups.BIG_BALL) {
    ballR = baseBallR;
    delete activePowerups.BIG_BALL;
  }
  if (activePowerups.SMALL_BALL && now > activePowerups.SMALL_BALL) {
    ballR = baseBallR;
    delete activePowerups.SMALL_BALL;
  }
  if (activePowerups.WIDE_PADDLE && now > activePowerups.WIDE_PADDLE) {
    paddleW = basePaddleW * levelConfig.paddleMult;
    delete activePowerups.WIDE_PADDLE;
  }
  if (activePowerups.NARROW_PADDLE && now > activePowerups.NARROW_PADDLE) {
    paddleW = basePaddleW * levelConfig.paddleMult;
    delete activePowerups.NARROW_PADDLE;
  }
  
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    p.y += p.speed;
    
    if (p.y + p.size >= paddleY && p.y <= paddleY + paddleH &&
        p.x + p.size >= paddleX && p.x <= paddleX + paddleW) {
      activatePowerup(p.type);
      powerups.splice(i, 1);
      continue;
    }
    
    if (p.y > H) powerups.splice(i, 1);
  }
}

function shootLaser() {
  if (!laserActive) return;
  lasers.push({
    x: paddleX + paddleW / 2 - 2 * scale,
    y: paddleY,
    width: 4 * scale,
    height: 15 * scale,
    speed: 8 * scale
  });
}

function updateLasers() {
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    l.y -= l.speed;
    
    let hit = false;
    for (let r = 0; r < brickRows && !hit; r++) {
      for (let c = 0; c < brickCols && !hit; c++) {
        const b = bricks[r][c];
        if (!b.alive) continue;
        if (l.x + l.width > b.x && l.x < b.x + brickW &&
            l.y < b.y + brickH && l.y + l.height > b.y) {
          b.alive = false;
          score++;
          spawnPowerup(b.x + brickW / 2, b.y + brickH);
          lasers.splice(i, 1);
          hit = true;
          if (countAliveBricks() === 0) showLevelComplete();
        }
      }
    }
    
    if (!hit && l.y + l.height < 0) lasers.splice(i, 1);
  }
}

function updateBrickMovement() {
  if (selectedDifficulty !== 'hard') return;
  
  const now = Date.now();
  if (now - brickMoveTimer >= BRICK_MOVE_INTERVAL) {
    brickMoveTimer = now;
    
    // Move all bricks down
    for (let r = 0; r < brickRows; r++) {
      for (let c = 0; c < brickCols; c++) {
        if (bricks[r][c].alive) {
          bricks[r][c].baseY += BRICK_MOVE_AMOUNT * scale * 10;
          
          // Check if bricks reached paddle level
          if (bricks[r][c].baseY + brickH >= paddleY) {
            gameOver = true;
            showGameOverScreen();
            return;
          }
        }
      }
    }
  }
}

function drawBricks() {
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const b = bricks[r][c];
      if (!b.alive) continue;
      b.x = brickOffsetLeft + c * (brickW + brickPad);
      b.y = b.baseY !== undefined ? b.baseY : brickOffsetTop + r * (brickH + brickPad);
      ctx.fillStyle = ACCENT;
      ctx.fillRect(b.x, b.y, brickW, brickH);
    }
  }
}

function drawPaddle() {
  ctx.fillStyle = ACCENT;
  ctx.fillRect(paddleX, paddleY, paddleW, paddleH);
  
  if (laserActive) {
    ctx.fillStyle = '#ff00ff';
    ctx.fillRect(paddleX + paddleW / 2 - 3 * scale, paddleY - 5 * scale, 6 * scale, 5 * scale);
  }
}

function drawBalls() {
  balls.forEach(ball => {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ballR, 0, Math.PI * 2);
    ctx.fillStyle = ACCENT;
    ctx.fill();
    ctx.closePath();
  });
}

function drawPowerups() {
  powerups.forEach(p => {
    const config = POWERUP_TYPES[p.type];
    ctx.save();
    ctx.translate(p.x, p.y);
    const svgScale = p.size / 77;
    ctx.scale(svgScale, svgScale);
    ctx.fillStyle = config.color;
    ctx.fill(POWERUP_SVG_PATH);
    ctx.restore();
  });
}

function drawLasers() {
  ctx.fillStyle = '#ff00ff';
  lasers.forEach(l => ctx.fillRect(l.x, l.y, l.width, l.height));
}

function drawHUD() {
  ctx.fillStyle = ACCENT;
  ctx.font = `${14 * scale}px sans-serif`;
  ctx.textAlign = 'left';
  ctx.fillText(`Score: ${score}`, 10, 24 * scale);
  ctx.fillText(`Lives: ${lives}`, W - 80 * scale, 24 * scale);
  
  // Level and difficulty display
  ctx.textAlign = 'center';
  const diffLabel = selectedDifficulty.toUpperCase();
  ctx.fillText(`Level ${currentLevel} | ${diffLabel}`, W / 2, 24 * scale);
  
  if (ballSticky && balls.length > 0 && balls[0].sticky) {
    ctx.fillStyle = ACCENT;
    ctx.font = `${16 * scale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(isMobile ? 'Tap to Launch' : 'Click to Launch', W / 2, H / 2);
  }
  
  let y = 45 * scale;
  const now = Date.now();
  for (const [type, expiry] of Object.entries(activePowerups)) {
    const remaining = Math.ceil((expiry - now) / 1000);
    if (remaining > 0) {
      ctx.fillStyle = POWERUP_TYPES[type].color;
      ctx.textAlign = 'left';
      ctx.fillText(`${type.replace('_', ' ')} ${remaining}s`, 10, y);
      y += 18 * scale;
    }
  }
}

function collisionDetection() {
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const b = bricks[r][c];
      if (!b.alive) continue;
      
      balls.forEach(ball => {
        if (ball.x > b.x && ball.x < b.x + brickW && ball.y - ballR < b.y + brickH && ball.y + ballR > b.y) {
          ball.dy = -ball.dy;
          if (b.alive) {
            b.alive = false;
            score++;
            spawnPowerup(b.x + brickW / 2, b.y + brickH);
            if (countAliveBricks() === 0) showLevelComplete();
          }
        }
      });
    }
  }
}

function update() {
  if (gameOver || !gameStarted || levelTransition) return;
  
  updatePowerups();
  updateLasers();
  updateBrickMovement();
  
  const levelConfig = LEVEL_CONFIGS[currentLevel];
  
  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];
    
    if (ball.sticky) {
      ball.x = paddleX + paddleW / 2;
      ball.y = paddleY - ballR - 2;
      continue;
    }
    
    ball.x += ball.dx;
    ball.y += ball.dy;
    
    if (ball.x + ballR > W || ball.x - ballR < 0) ball.dx = -ball.dx;
    if (ball.y - ballR < 0) ball.dy = -ball.dy;
    
    if (ball.y + ballR >= paddleY && ball.x > paddleX && ball.x < paddleX + paddleW) {
      ball.dy = -Math.abs(ball.dy);
      let hit = (ball.x - paddleX) / paddleW - 0.5;
      ball.dx = hit * 6 * scale;
    }
    
    if (ball.y - ballR > H) balls.splice(i, 1);
  }
  
  if (balls.length === 0) {
    lives--;
    if (lives <= 0) { 
      gameOver = true; 
      showGameOverScreen(); 
    } else { 
      ballSticky = true;
      const speed = baseSpeed * levelConfig.speedMult;
      balls = [createBall(paddleX + paddleW / 2, paddleY - ballR - 2, 3 * scale * (Math.random() > 0.5 ? 1 : -1), -speed)];
      balls[0].sticky = true;
    }
  }
  
  collisionDetection();
}

function draw() {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);
  drawBricks();
  drawPaddle();
  drawBalls();
  drawPowerups();
  drawLasers();
  drawHUD();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

function movePaddle(x) {
  const rect = canvas.getBoundingClientRect();
  const canvasX = x - rect.left;
  paddleX = canvasX - paddleW / 2;
  if (paddleX < 0) paddleX = 0;
  if (paddleX + paddleW > W) paddleX = W - paddleW;
  
  if (ballSticky && balls.length > 0 && balls[0].sticky) {
    balls[0].x = paddleX + paddleW / 2;
  }
}

canvas.addEventListener('mousemove', e => movePaddle(e.clientX));
canvas.addEventListener('touchmove', e => { 
  e.preventDefault(); 
  movePaddle(e.touches[0].clientX); 
}, { passive: false });

function handleClick() {
  if (ballSticky && balls.length > 0 && balls[0].sticky) {
    launchBall();
  } else if (laserActive) {
    shootLaser();
  }
}

canvas.addEventListener('click', handleClick);
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  handleClick();
}, { passive: false });

document.addEventListener('keydown', e => { 
  if (e.code === 'Space') {
    e.preventDefault();
    handleClick();
  }
});

window.addEventListener('resize', () => {
  resize();
  // Recalculate brick positions on resize
  if (bricks.length > 0 && brickCols > 0) {
    brickW = (W - brickOffsetLeft * 2 - brickPad * (brickCols - 1)) / brickCols;
  }
});

resize();
loop();
</script>
</body>
</html>
