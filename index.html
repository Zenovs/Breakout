<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Breakout</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #0b0b0b; }
    canvas { display: block; margin: auto; touch-action: none; }
    
    /* Game Over Overlay */
    #gameOverOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(11, 11, 11, 0.95);
      z-index: 100;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      color: #6cff00;
    }
    #gameOverOverlay.show { display: flex; }
    #gameOverOverlay h1 { font-size: 2.5rem; margin-bottom: 1rem; }
    #gameOverOverlay .final-score { font-size: 1.5rem; margin-bottom: 1.5rem; }
    #gameOverOverlay input {
      background: #0b0b0b;
      border: 2px solid #6cff00;
      color: #6cff00;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      width: 200px;
      text-align: center;
      margin-bottom: 1rem;
    }
    #gameOverOverlay input::placeholder { color: #3a7a00; }
    #gameOverOverlay button {
      background: #6cff00;
      color: #0b0b0b;
      border: none;
      padding: 0.75rem 2rem;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 2rem;
    }
    #gameOverOverlay button:hover { background: #5de000; }
    
    /* Leaderboard */
    #leaderboard {
      background: #0b0b0b;
      border: 2px solid #6cff00;
      padding: 1rem 1.5rem;
      max-width: 280px;
      width: 90%;
    }
    #leaderboard h2 { font-size: 1.2rem; margin-bottom: 0.75rem; text-align: center; }
    #leaderboard ol {
      list-style-position: inside;
      padding: 0;
    }
    #leaderboard li {
      display: flex;
      justify-content: space-between;
      padding: 0.3rem 0;
      border-bottom: 1px solid #1a3300;
    }
    #leaderboard li:last-child { border-bottom: none; }
    #leaderboard .name { flex: 1; overflow: hidden; text-overflow: ellipsis; }
    #leaderboard .score-val { font-weight: bold; margin-left: 1rem; }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<div id="gameOverOverlay">
  <h1 id="gameOverTitle">Game Over</h1>
  <div class="final-score">Score: <span id="finalScore">0</span></div>
  <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
  <button id="submitScore">Save & Play Again</button>
  <div id="leaderboard">
    <h2>üèÜ Top 10 High Scores</h2>
    <ol id="highScoreList"></ol>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ACCENT = '#6cff00';
const BG = '#0b0b0b';

let W, H, scale;
let paddleW, paddleH, paddleX, paddleY, basePaddleW;
let ballR, baseBallR;
let brickRows = 5, brickCols = 8, brickW, brickH, brickPad, brickOffsetTop, brickOffsetLeft;
let bricks = [];
let score = 0, lives = 3, gameOver = false, won = false;

// Multi-ball support
let balls = [];

// Power-up system
const POWERUP_TYPES = {
  MULTI_BALL: { color: '#ff6b6b', icon: '‚ö™‚ö™', duration: 0 },
  LASER: { color: '#ff00ff', icon: 'üî´', duration: 8000 },
  BIG_BALL: { color: '#00ffff', icon: '‚¨§', duration: 10000 },
  SMALL_BALL: { color: '#ff8800', icon: '‚Ä¢', duration: 10000 },
  WIDE_PADDLE: { color: '#00ff88', icon: '‚ñ¨‚ñ¨', duration: 10000 },
  NARROW_PADDLE: { color: '#ff4444', icon: '‚ñ¨', duration: 10000 }
};
let powerups = [];
let activePowerups = {};
let lasers = [];
let laserActive = false;

// High Score Functions
function getHighScores() {
  const data = localStorage.getItem('breakoutHighScores');
  return data ? JSON.parse(data) : [];
}

function saveHighScore(name, playerScore) {
  const scores = getHighScores();
  scores.push({ name: name || 'Anonymous', score: playerScore });
  scores.sort((a, b) => b.score - a.score);
  const top10 = scores.slice(0, 10);
  localStorage.setItem('breakoutHighScores', JSON.stringify(top10));
  return top10;
}

function renderLeaderboard() {
  const scores = getHighScores();
  const list = document.getElementById('highScoreList');
  if (scores.length === 0) {
    list.innerHTML = '<li style="justify-content:center;">No scores yet!</li>';
  } else {
    list.innerHTML = scores.map((s, i) => 
      `<li><span class="name">${i + 1}. ${s.name}</span><span class="score-val">${s.score}</span></li>`
    ).join('');
  }
}

function showGameOverScreen() {
  document.getElementById('gameOverTitle').textContent = won ? 'You Win!' : 'Game Over';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('playerName').value = '';
  renderLeaderboard();
  document.getElementById('gameOverOverlay').classList.add('show');
  document.getElementById('playerName').focus();
}

function hideGameOverScreen() {
  document.getElementById('gameOverOverlay').classList.remove('show');
}

document.getElementById('submitScore').addEventListener('click', () => {
  const name = document.getElementById('playerName').value.trim();
  saveHighScore(name, score);
  hideGameOverScreen();
  initGame();
});

document.getElementById('playerName').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') document.getElementById('submitScore').click();
});

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  scale = Math.min(W / 480, H / 640);
  basePaddleW = 80 * scale;
  paddleW = basePaddleW;
  paddleH = 12 * scale;
  paddleY = H - 40 * scale;
  baseBallR = 8 * scale;
  ballR = baseBallR;
  brickPad = 6 * scale;
  brickOffsetTop = 50 * scale;
  brickOffsetLeft = 20 * scale;
  brickW = (W - brickOffsetLeft * 2 - brickPad * (brickCols - 1)) / brickCols;
  brickH = 18 * scale;
}

function createBall(x, y, dx, dy) {
  return { x, y, dx, dy };
}

function initGame() {
  resize();
  paddleX = (W - paddleW) / 2;
  paddleW = basePaddleW;
  ballR = baseBallR;
  
  balls = [createBall(W / 2, paddleY - ballR - 2, 3 * scale * (Math.random() > 0.5 ? 1 : -1), -4 * scale)];
  
  score = 0; lives = 3; gameOver = false; won = false;
  powerups = [];
  activePowerups = {};
  lasers = [];
  laserActive = false;
  
  bricks = [];
  for (let r = 0; r < brickRows; r++) {
    bricks[r] = [];
    for (let c = 0; c < brickCols; c++) {
      bricks[r][c] = { x: 0, y: 0, alive: true };
    }
  }
}

// Power-up functions
function spawnPowerup(x, y) {
  if (Math.random() > 0.25) return; // 25% chance to spawn
  const types = Object.keys(POWERUP_TYPES);
  const type = types[Math.floor(Math.random() * types.length)];
  powerups.push({
    x, y,
    type,
    width: 30 * scale,
    height: 15 * scale,
    speed: 2 * scale
  });
}

function activatePowerup(type) {
  const now = Date.now();
  const config = POWERUP_TYPES[type];
  
  switch(type) {
    case 'MULTI_BALL':
      // Spawn 2 extra balls from first ball position
      if (balls.length > 0) {
        const b = balls[0];
        balls.push(createBall(b.x, b.y, -3 * scale, -4 * scale));
        balls.push(createBall(b.x, b.y, 3 * scale, -4 * scale));
      }
      break;
    case 'LASER':
      laserActive = true;
      activePowerups.LASER = now + config.duration;
      break;
    case 'BIG_BALL':
      ballR = baseBallR * 1.8;
      activePowerups.BIG_BALL = now + config.duration;
      delete activePowerups.SMALL_BALL;
      break;
    case 'SMALL_BALL':
      ballR = baseBallR * 0.5;
      activePowerups.SMALL_BALL = now + config.duration;
      delete activePowerups.BIG_BALL;
      break;
    case 'WIDE_PADDLE':
      paddleW = basePaddleW * 1.5;
      activePowerups.WIDE_PADDLE = now + config.duration;
      delete activePowerups.NARROW_PADDLE;
      break;
    case 'NARROW_PADDLE':
      paddleW = basePaddleW * 0.6;
      activePowerups.NARROW_PADDLE = now + config.duration;
      delete activePowerups.WIDE_PADDLE;
      break;
  }
}

function updatePowerups() {
  const now = Date.now();
  
  // Check expired powerups
  if (activePowerups.LASER && now > activePowerups.LASER) {
    laserActive = false;
    delete activePowerups.LASER;
  }
  if (activePowerups.BIG_BALL && now > activePowerups.BIG_BALL) {
    ballR = baseBallR;
    delete activePowerups.BIG_BALL;
  }
  if (activePowerups.SMALL_BALL && now > activePowerups.SMALL_BALL) {
    ballR = baseBallR;
    delete activePowerups.SMALL_BALL;
  }
  if (activePowerups.WIDE_PADDLE && now > activePowerups.WIDE_PADDLE) {
    paddleW = basePaddleW;
    delete activePowerups.WIDE_PADDLE;
  }
  if (activePowerups.NARROW_PADDLE && now > activePowerups.NARROW_PADDLE) {
    paddleW = basePaddleW;
    delete activePowerups.NARROW_PADDLE;
  }
  
  // Update falling powerups
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    p.y += p.speed;
    
    // Check paddle collision
    if (p.y + p.height >= paddleY && p.y <= paddleY + paddleH &&
        p.x + p.width >= paddleX && p.x <= paddleX + paddleW) {
      activatePowerup(p.type);
      powerups.splice(i, 1);
      continue;
    }
    
    // Remove if off screen
    if (p.y > H) {
      powerups.splice(i, 1);
    }
  }
}

function shootLaser() {
  if (!laserActive) return;
  lasers.push({
    x: paddleX + paddleW / 2 - 2 * scale,
    y: paddleY,
    width: 4 * scale,
    height: 15 * scale,
    speed: 8 * scale
  });
}

function updateLasers() {
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    l.y -= l.speed;
    
    // Check brick collision
    let hit = false;
    for (let r = 0; r < brickRows && !hit; r++) {
      for (let c = 0; c < brickCols && !hit; c++) {
        const b = bricks[r][c];
        if (!b.alive) continue;
        if (l.x + l.width > b.x && l.x < b.x + brickW &&
            l.y < b.y + brickH && l.y + l.height > b.y) {
          b.alive = false;
          score++;
          spawnPowerup(b.x + brickW / 2, b.y + brickH);
          lasers.splice(i, 1);
          hit = true;
          if (score === brickRows * brickCols) { won = true; gameOver = true; showGameOverScreen(); }
        }
      }
    }
    
    // Remove if off screen
    if (!hit && l.y + l.height < 0) {
      lasers.splice(i, 1);
    }
  }
}

function drawBricks() {
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const b = bricks[r][c];
      if (!b.alive) continue;
      b.x = brickOffsetLeft + c * (brickW + brickPad);
      b.y = brickOffsetTop + r * (brickH + brickPad);
      ctx.fillStyle = ACCENT;
      ctx.fillRect(b.x, b.y, brickW, brickH);
    }
  }
}

function drawPaddle() {
  ctx.fillStyle = ACCENT;
  ctx.fillRect(paddleX, paddleY, paddleW, paddleH);
  
  // Draw laser indicator
  if (laserActive) {
    ctx.fillStyle = '#ff00ff';
    ctx.fillRect(paddleX + paddleW / 2 - 3 * scale, paddleY - 5 * scale, 6 * scale, 5 * scale);
  }
}

function drawBalls() {
  balls.forEach(ball => {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ballR, 0, Math.PI * 2);
    ctx.fillStyle = ACCENT;
    ctx.fill();
    ctx.closePath();
  });
}

function drawPowerups() {
  powerups.forEach(p => {
    const config = POWERUP_TYPES[p.type];
    ctx.fillStyle = config.color;
    ctx.fillRect(p.x, p.y, p.width, p.height);
    ctx.fillStyle = '#fff';
    ctx.font = `${10 * scale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(config.icon, p.x + p.width / 2, p.y + p.height / 2 + 3 * scale);
  });
}

function drawLasers() {
  ctx.fillStyle = '#ff00ff';
  lasers.forEach(l => {
    ctx.fillRect(l.x, l.y, l.width, l.height);
  });
}

function drawHUD() {
  ctx.fillStyle = ACCENT;
  ctx.font = `${14 * scale}px sans-serif`;
  ctx.textAlign = 'left';
  ctx.fillText(`Score: ${score}`, 10, 24 * scale);
  ctx.fillText(`Lives: ${lives}`, W - 80 * scale, 24 * scale);
  
  // Draw active powerup indicators
  let y = 45 * scale;
  const now = Date.now();
  for (const [type, expiry] of Object.entries(activePowerups)) {
    const remaining = Math.ceil((expiry - now) / 1000);
    if (remaining > 0) {
      ctx.fillStyle = POWERUP_TYPES[type].color;
      ctx.fillText(`${POWERUP_TYPES[type].icon} ${remaining}s`, 10, y);
      y += 18 * scale;
    }
  }
}

function collisionDetection() {
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const b = bricks[r][c];
      if (!b.alive) continue;
      
      balls.forEach(ball => {
        if (ball.x > b.x && ball.x < b.x + brickW && ball.y - ballR < b.y + brickH && ball.y + ballR > b.y) {
          ball.dy = -ball.dy;
          if (b.alive) {
            b.alive = false;
            score++;
            spawnPowerup(b.x + brickW / 2, b.y + brickH);
            if (score === brickRows * brickCols) { won = true; gameOver = true; showGameOverScreen(); }
          }
        }
      });
    }
  }
}

function update() {
  if (gameOver) return;
  
  updatePowerups();
  updateLasers();
  
  // Update all balls
  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];
    ball.x += ball.dx;
    ball.y += ball.dy;
    
    // walls
    if (ball.x + ballR > W || ball.x - ballR < 0) ball.dx = -ball.dx;
    if (ball.y - ballR < 0) ball.dy = -ball.dy;
    
    // paddle
    if (ball.y + ballR >= paddleY && ball.x > paddleX && ball.x < paddleX + paddleW) {
      ball.dy = -Math.abs(ball.dy);
      let hit = (ball.x - paddleX) / paddleW - 0.5;
      ball.dx = hit * 6 * scale;
    }
    
    // bottom - remove ball
    if (ball.y - ballR > H) {
      balls.splice(i, 1);
    }
  }
  
  // If no balls left, lose a life
  if (balls.length === 0) {
    lives--;
    if (lives <= 0) { 
      gameOver = true; 
      showGameOverScreen(); 
    } else { 
      balls = [createBall(W / 2, paddleY - ballR - 2, 3 * scale * (Math.random() > 0.5 ? 1 : -1), -4 * scale)];
    }
  }
  
  collisionDetection();
}

function draw() {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);
  drawBricks();
  drawPaddle();
  drawBalls();
  drawPowerups();
  drawLasers();
  drawHUD();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Controls
function movePaddle(x) {
  paddleX = x - paddleW / 2;
  if (paddleX < 0) paddleX = 0;
  if (paddleX + paddleW > W) paddleX = W - paddleW;
}
canvas.addEventListener('mousemove', e => movePaddle(e.clientX));
canvas.addEventListener('touchmove', e => { e.preventDefault(); movePaddle(e.touches[0].clientX); }, { passive: false });

// Laser shooting
canvas.addEventListener('click', shootLaser);
canvas.addEventListener('touchstart', e => { if (laserActive) shootLaser(); });
document.addEventListener('keydown', e => { if (e.code === 'Space' && laserActive) shootLaser(); });

window.addEventListener('resize', resize);

initGame();
loop();
</script>
</body>
</html>
