<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Breakout</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #0b0b0b; }
    canvas { display: block; margin: auto; touch-action: none; }
    
    /* Start Screen Overlay */
    #startOverlay {
      display: flex;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(11, 11, 11, 0.95);
      z-index: 100;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Courier New', monospace;
      color: #6cff00;
      cursor: pointer;
    }
    #startOverlay.hidden { display: none; }
    #startOverlay h1 {
      font-size: 3rem;
      text-transform: uppercase;
      letter-spacing: 0.3rem;
      margin-bottom: 2rem;
      text-shadow: 0 0 20px #6cff00, 0 0 40px #6cff00;
      animation: pulse 1.5s ease-in-out infinite;
    }
    #startOverlay .click-text {
      font-size: 1.5rem;
      animation: blink 1s step-end infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    
    /* Game Over Overlay */
    #gameOverOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(11, 11, 11, 0.95);
      z-index: 100;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      color: #6cff00;
    }
    #gameOverOverlay.show { display: flex; }
    #gameOverOverlay h1 { font-size: 2.5rem; margin-bottom: 1rem; }
    #gameOverOverlay .final-score { font-size: 1.5rem; margin-bottom: 1.5rem; }
    #gameOverOverlay input {
      background: #0b0b0b;
      border: 2px solid #6cff00;
      color: #6cff00;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      width: 200px;
      text-align: center;
      margin-bottom: 1rem;
    }
    #gameOverOverlay input::placeholder { color: #3a7a00; }
    #gameOverOverlay button {
      background: #6cff00;
      color: #0b0b0b;
      border: none;
      padding: 0.75rem 2rem;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 2rem;
    }
    #gameOverOverlay button:hover { background: #5de000; }
    
    /* Leaderboard */
    #leaderboard {
      background: #0b0b0b;
      border: 2px solid #6cff00;
      padding: 1rem 1.5rem;
      max-width: 280px;
      width: 90%;
    }
    #leaderboard h2 { font-size: 1.2rem; margin-bottom: 0.75rem; text-align: center; }
    #leaderboard ol {
      list-style-position: inside;
      padding: 0;
    }
    #leaderboard li {
      display: flex;
      justify-content: space-between;
      padding: 0.3rem 0;
      border-bottom: 1px solid #1a3300;
    }
    #leaderboard li:last-child { border-bottom: none; }
    #leaderboard .name { flex: 1; overflow: hidden; text-overflow: ellipsis; }
    #leaderboard .score-val { font-weight: bold; margin-left: 1rem; }
  </style>
</head>
<body>
<div id="startOverlay">
  <h1>Breakout</h1>
  <div class="click-text">Click to Start</div>
</div>

<canvas id="game"></canvas>

<div id="gameOverOverlay">
  <h1 id="gameOverTitle">Game Over</h1>
  <div class="final-score">Score: <span id="finalScore">0</span></div>
  <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
  <button id="submitScore">Save & Play Again</button>
  <div id="leaderboard">
    <h2>üèÜ Top 10 High Scores</h2>
    <ol id="highScoreList"></ol>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ACCENT = '#6cff00';
const BG = '#0b0b0b';

// Mobile detection
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                 ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

let W, H, scale;
let paddleW, paddleH, paddleX, paddleY, basePaddleW;
let ballR, baseBallR;
let brickRows = 5, brickCols = 8, brickW, brickH, brickPad, brickOffsetTop, brickOffsetLeft;
let bricks = [];
let score = 0, lives = 3, gameOver = false, won = false;
let gameStarted = false;
let ballSticky = true; // Ball sticks to paddle

// Multi-ball support
let balls = [];

// Power-up system
const POWERUP_TYPES = {
  MULTI_BALL: { color: '#ff6b6b', duration: 0 },
  LASER: { color: '#ff00ff', duration: 8000 },
  BIG_BALL: { color: '#00ffff', duration: 10000 },
  SMALL_BALL: { color: '#ff8800', duration: 10000 },
  WIDE_PADDLE: { color: '#00ff88', duration: 10000 },
  NARROW_PADDLE: { color: '#ff4444', duration: 10000 }
};

// SVG Path for power-up S-logo
const POWERUP_SVG_PATH = new Path2D('M38.7837 0C17.3672 0 0 17.3672 0 38.7837C0 60.2003 17.3672 77.5675 38.7837 77.5675C60.2062 77.5675 77.5675 60.2003 77.5675 38.7837C77.5675 17.3612 60.2062 0 38.7837 0ZM35.4766 65.8469L23.9934 66.8859L24.1359 50.2372L35.5894 52.4222L35.4766 65.8469ZM50.8072 64.4575L39.3241 65.4966L39.4309 53.2356L50.8844 55.5334L50.8072 64.4575ZM61.7975 52.6834L21.9984 44.8341C16.0609 42.9103 11.3109 39.5022 11.3822 31.4034C11.5009 17.5394 23.2037 10.5212 35.3519 9.42281C48.1591 8.265 59.4403 12.1956 59.8144 26.7662L42.6253 28.3219C42.9756 26.0241 41.9959 24.5991 40.5175 23.7262C39.0391 22.7703 36.9787 22.5387 35.1559 22.6991C32.6741 22.9247 28.6187 23.9637 28.595 27.3244C28.8919 31.5816 37.3112 31.7419 45.6356 33.3391C53.9659 34.9362 62.1953 38.1366 62.1003 49.1387C62.0884 50.3797 61.9816 51.5553 61.7975 52.6834Z');

let powerups = [];
let activePowerups = {};
let lasers = [];
let laserActive = false;

// High Score Functions
function getHighScores() {
  const data = localStorage.getItem('breakoutHighScores');
  return data ? JSON.parse(data) : [];
}

function saveHighScore(name, playerScore) {
  const scores = getHighScores();
  scores.push({ name: name || 'Anonymous', score: playerScore });
  scores.sort((a, b) => b.score - a.score);
  const top10 = scores.slice(0, 10);
  localStorage.setItem('breakoutHighScores', JSON.stringify(top10));
  return top10;
}

function renderLeaderboard() {
  const scores = getHighScores();
  const list = document.getElementById('highScoreList');
  if (scores.length === 0) {
    list.innerHTML = '<li style="justify-content:center;">No scores yet!</li>';
  } else {
    list.innerHTML = scores.map((s, i) => 
      `<li><span class="name">${i + 1}. ${s.name}</span><span class="score-val">${s.score}</span></li>`
    ).join('');
  }
}

function showGameOverScreen() {
  document.getElementById('gameOverTitle').textContent = won ? 'You Win!' : 'Game Over';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('playerName').value = '';
  renderLeaderboard();
  document.getElementById('gameOverOverlay').classList.add('show');
  document.getElementById('playerName').focus();
}

function hideGameOverScreen() {
  document.getElementById('gameOverOverlay').classList.remove('show');
}

document.getElementById('submitScore').addEventListener('click', () => {
  const name = document.getElementById('playerName').value.trim();
  saveHighScore(name, score);
  hideGameOverScreen();
  initGame();
});

document.getElementById('playerName').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') document.getElementById('submitScore').click();
});

// Start screen handler
document.getElementById('startOverlay').addEventListener('click', () => {
  document.getElementById('startOverlay').classList.add('hidden');
  gameStarted = true;
  initGame();
});

function resize() {
  // Responsive canvas - adapt to screen width
  const maxWidth = isMobile ? window.innerWidth : Math.min(window.innerWidth, 800);
  const maxHeight = window.innerHeight;
  
  // Maintain aspect ratio roughly 3:4
  const aspectRatio = 3 / 4;
  
  if (maxWidth / maxHeight < aspectRatio) {
    W = maxWidth;
    H = W / aspectRatio;
  } else {
    H = maxHeight;
    W = H * aspectRatio;
  }
  
  canvas.width = W;
  canvas.height = H;
  
  // Center canvas
  canvas.style.position = 'absolute';
  canvas.style.left = (window.innerWidth - W) / 2 + 'px';
  canvas.style.top = (window.innerHeight - H) / 2 + 'px';
  
  scale = Math.min(W / 480, H / 640);
  basePaddleW = 80 * scale;
  paddleW = basePaddleW;
  paddleH = 12 * scale;
  paddleY = H - 40 * scale;
  baseBallR = 8 * scale;
  ballR = baseBallR;
  brickPad = 6 * scale;
  brickOffsetTop = 50 * scale;
  brickOffsetLeft = 20 * scale;
  brickW = (W - brickOffsetLeft * 2 - brickPad * (brickCols - 1)) / brickCols;
  brickH = 18 * scale;
}

function createBall(x, y, dx, dy) {
  return { x, y, dx, dy, sticky: false };
}

function initGame() {
  resize();
  paddleX = (W - paddleW) / 2;
  paddleW = basePaddleW;
  ballR = baseBallR;
  
  // Ball starts sticky on paddle
  ballSticky = true;
  balls = [createBall(paddleX + paddleW / 2, paddleY - ballR - 2, 3 * scale * (Math.random() > 0.5 ? 1 : -1), -4 * scale)];
  balls[0].sticky = true;
  
  score = 0; lives = 3; gameOver = false; won = false;
  powerups = [];
  activePowerups = {};
  lasers = [];
  laserActive = false;
  
  bricks = [];
  for (let r = 0; r < brickRows; r++) {
    bricks[r] = [];
    for (let c = 0; c < brickCols; c++) {
      bricks[r][c] = { x: 0, y: 0, alive: true };
    }
  }
}

// Launch ball from paddle
function launchBall() {
  if (ballSticky && balls.length > 0 && balls[0].sticky) {
    balls[0].sticky = false;
    ballSticky = false;
  }
}

// Power-up functions
function spawnPowerup(x, y) {
  if (Math.random() > 0.25) return; // 25% chance to spawn
  const types = Object.keys(POWERUP_TYPES);
  const type = types[Math.floor(Math.random() * types.length)];
  powerups.push({
    x, y,
    type,
    size: 24 * scale,
    speed: 2 * scale
  });
}

function activatePowerup(type) {
  const now = Date.now();
  const config = POWERUP_TYPES[type];
  
  switch(type) {
    case 'MULTI_BALL':
      if (balls.length > 0) {
        const b = balls[0];
        balls.push(createBall(b.x, b.y, -3 * scale, -4 * scale));
        balls.push(createBall(b.x, b.y, 3 * scale, -4 * scale));
      }
      break;
    case 'LASER':
      laserActive = true;
      activePowerups.LASER = now + config.duration;
      break;
    case 'BIG_BALL':
      ballR = baseBallR * 1.8;
      activePowerups.BIG_BALL = now + config.duration;
      delete activePowerups.SMALL_BALL;
      break;
    case 'SMALL_BALL':
      ballR = baseBallR * 0.5;
      activePowerups.SMALL_BALL = now + config.duration;
      delete activePowerups.BIG_BALL;
      break;
    case 'WIDE_PADDLE':
      paddleW = basePaddleW * 1.5;
      activePowerups.WIDE_PADDLE = now + config.duration;
      delete activePowerups.NARROW_PADDLE;
      break;
    case 'NARROW_PADDLE':
      paddleW = basePaddleW * 0.6;
      activePowerups.NARROW_PADDLE = now + config.duration;
      delete activePowerups.WIDE_PADDLE;
      break;
  }
}

function updatePowerups() {
  const now = Date.now();
  
  if (activePowerups.LASER && now > activePowerups.LASER) {
    laserActive = false;
    delete activePowerups.LASER;
  }
  if (activePowerups.BIG_BALL && now > activePowerups.BIG_BALL) {
    ballR = baseBallR;
    delete activePowerups.BIG_BALL;
  }
  if (activePowerups.SMALL_BALL && now > activePowerups.SMALL_BALL) {
    ballR = baseBallR;
    delete activePowerups.SMALL_BALL;
  }
  if (activePowerups.WIDE_PADDLE && now > activePowerups.WIDE_PADDLE) {
    paddleW = basePaddleW;
    delete activePowerups.WIDE_PADDLE;
  }
  if (activePowerups.NARROW_PADDLE && now > activePowerups.NARROW_PADDLE) {
    paddleW = basePaddleW;
    delete activePowerups.NARROW_PADDLE;
  }
  
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    p.y += p.speed;
    
    if (p.y + p.size >= paddleY && p.y <= paddleY + paddleH &&
        p.x + p.size >= paddleX && p.x <= paddleX + paddleW) {
      activatePowerup(p.type);
      powerups.splice(i, 1);
      continue;
    }
    
    if (p.y > H) {
      powerups.splice(i, 1);
    }
  }
}

function shootLaser() {
  if (!laserActive) return;
  lasers.push({
    x: paddleX + paddleW / 2 - 2 * scale,
    y: paddleY,
    width: 4 * scale,
    height: 15 * scale,
    speed: 8 * scale
  });
}

function updateLasers() {
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    l.y -= l.speed;
    
    let hit = false;
    for (let r = 0; r < brickRows && !hit; r++) {
      for (let c = 0; c < brickCols && !hit; c++) {
        const b = bricks[r][c];
        if (!b.alive) continue;
        if (l.x + l.width > b.x && l.x < b.x + brickW &&
            l.y < b.y + brickH && l.y + l.height > b.y) {
          b.alive = false;
          score++;
          spawnPowerup(b.x + brickW / 2, b.y + brickH);
          lasers.splice(i, 1);
          hit = true;
          if (score === brickRows * brickCols) { won = true; gameOver = true; showGameOverScreen(); }
        }
      }
    }
    
    if (!hit && l.y + l.height < 0) {
      lasers.splice(i, 1);
    }
  }
}

function drawBricks() {
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const b = bricks[r][c];
      if (!b.alive) continue;
      b.x = brickOffsetLeft + c * (brickW + brickPad);
      b.y = brickOffsetTop + r * (brickH + brickPad);
      ctx.fillStyle = ACCENT;
      ctx.fillRect(b.x, b.y, brickW, brickH);
    }
  }
}

function drawPaddle() {
  ctx.fillStyle = ACCENT;
  ctx.fillRect(paddleX, paddleY, paddleW, paddleH);
  
  if (laserActive) {
    ctx.fillStyle = '#ff00ff';
    ctx.fillRect(paddleX + paddleW / 2 - 3 * scale, paddleY - 5 * scale, 6 * scale, 5 * scale);
  }
}

function drawBalls() {
  balls.forEach(ball => {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ballR, 0, Math.PI * 2);
    ctx.fillStyle = ACCENT;
    ctx.fill();
    ctx.closePath();
  });
}

function drawPowerups() {
  powerups.forEach(p => {
    const config = POWERUP_TYPES[p.type];
    ctx.save();
    ctx.translate(p.x, p.y);
    // Scale SVG path (original is ~77x77) to fit power-up size
    const svgScale = p.size / 77;
    ctx.scale(svgScale, svgScale);
    ctx.fillStyle = config.color;
    ctx.fill(POWERUP_SVG_PATH);
    ctx.restore();
  });
}

function drawLasers() {
  ctx.fillStyle = '#ff00ff';
  lasers.forEach(l => {
    ctx.fillRect(l.x, l.y, l.width, l.height);
  });
}

function drawHUD() {
  ctx.fillStyle = ACCENT;
  ctx.font = `${14 * scale}px sans-serif`;
  ctx.textAlign = 'left';
  ctx.fillText(`Score: ${score}`, 10, 24 * scale);
  ctx.fillText(`Lives: ${lives}`, W - 80 * scale, 24 * scale);
  
  // Show "Click to Launch" when ball is sticky
  if (ballSticky && balls.length > 0 && balls[0].sticky) {
    ctx.fillStyle = ACCENT;
    ctx.font = `${16 * scale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(isMobile ? 'Tap to Launch' : 'Click to Launch', W / 2, H / 2);
  }
  
  let y = 45 * scale;
  const now = Date.now();
  for (const [type, expiry] of Object.entries(activePowerups)) {
    const remaining = Math.ceil((expiry - now) / 1000);
    if (remaining > 0) {
      ctx.fillStyle = POWERUP_TYPES[type].color;
      ctx.textAlign = 'left';
      ctx.fillText(`${type.replace('_', ' ')} ${remaining}s`, 10, y);
      y += 18 * scale;
    }
  }
}

function collisionDetection() {
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const b = bricks[r][c];
      if (!b.alive) continue;
      
      balls.forEach(ball => {
        if (ball.x > b.x && ball.x < b.x + brickW && ball.y - ballR < b.y + brickH && ball.y + ballR > b.y) {
          ball.dy = -ball.dy;
          if (b.alive) {
            b.alive = false;
            score++;
            spawnPowerup(b.x + brickW / 2, b.y + brickH);
            if (score === brickRows * brickCols) { won = true; gameOver = true; showGameOverScreen(); }
          }
        }
      });
    }
  }
}

function update() {
  if (gameOver || !gameStarted) return;
  
  updatePowerups();
  updateLasers();
  
  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];
    
    // If ball is sticky, keep it on paddle
    if (ball.sticky) {
      ball.x = paddleX + paddleW / 2;
      ball.y = paddleY - ballR - 2;
      continue;
    }
    
    ball.x += ball.dx;
    ball.y += ball.dy;
    
    if (ball.x + ballR > W || ball.x - ballR < 0) ball.dx = -ball.dx;
    if (ball.y - ballR < 0) ball.dy = -ball.dy;
    
    if (ball.y + ballR >= paddleY && ball.x > paddleX && ball.x < paddleX + paddleW) {
      ball.dy = -Math.abs(ball.dy);
      let hit = (ball.x - paddleX) / paddleW - 0.5;
      ball.dx = hit * 6 * scale;
    }
    
    if (ball.y - ballR > H) {
      balls.splice(i, 1);
    }
  }
  
  if (balls.length === 0) {
    lives--;
    if (lives <= 0) { 
      gameOver = true; 
      showGameOverScreen(); 
    } else { 
      // Reset ball sticky on paddle after losing life
      ballSticky = true;
      balls = [createBall(paddleX + paddleW / 2, paddleY - ballR - 2, 3 * scale * (Math.random() > 0.5 ? 1 : -1), -4 * scale)];
      balls[0].sticky = true;
    }
  }
  
  collisionDetection();
}

function draw() {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);
  drawBricks();
  drawPaddle();
  drawBalls();
  drawPowerups();
  drawLasers();
  drawHUD();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Controls
function movePaddle(x) {
  // Adjust for canvas offset
  const rect = canvas.getBoundingClientRect();
  const canvasX = x - rect.left;
  paddleX = canvasX - paddleW / 2;
  if (paddleX < 0) paddleX = 0;
  if (paddleX + paddleW > W) paddleX = W - paddleW;
  
  // Move sticky ball with paddle
  if (ballSticky && balls.length > 0 && balls[0].sticky) {
    balls[0].x = paddleX + paddleW / 2;
  }
}

// Mouse controls
canvas.addEventListener('mousemove', e => movePaddle(e.clientX));

// Touch controls for mobile
canvas.addEventListener('touchmove', e => { 
  e.preventDefault(); 
  movePaddle(e.touches[0].clientX); 
}, { passive: false });

// Click/tap to launch ball or shoot laser
function handleClick() {
  if (ballSticky && balls.length > 0 && balls[0].sticky) {
    launchBall();
  } else if (laserActive) {
    shootLaser();
  }
}

canvas.addEventListener('click', handleClick);
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  handleClick();
}, { passive: false });

document.addEventListener('keydown', e => { 
  if (e.code === 'Space') {
    e.preventDefault();
    handleClick();
  }
});

window.addEventListener('resize', resize);

// Initialize
resize();
loop();
</script>
</body>
</html>
