<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Breakout</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #0b0b0b; }
    canvas { display: block; margin: auto; touch-action: none; }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ACCENT = '#6cff00';
const BG = '#0b0b0b';

let W, H, scale;
let paddleW, paddleH, paddleX, paddleY;
let ballR, ballX, ballY, ballDX, ballDY;
let brickRows = 5, brickCols = 8, brickW, brickH, brickPad, brickOffsetTop, brickOffsetLeft;
let bricks = [];
let score = 0, lives = 3, gameOver = false, won = false;

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  scale = Math.min(W / 480, H / 640);
  paddleW = 80 * scale;
  paddleH = 12 * scale;
  paddleY = H - 40 * scale;
  ballR = 8 * scale;
  brickPad = 6 * scale;
  brickOffsetTop = 50 * scale;
  brickOffsetLeft = 20 * scale;
  brickW = (W - brickOffsetLeft * 2 - brickPad * (brickCols - 1)) / brickCols;
  brickH = 18 * scale;
}

function initGame() {
  resize();
  paddleX = (W - paddleW) / 2;
  ballX = W / 2;
  ballY = paddleY - ballR - 2;
  ballDX = 3 * scale * (Math.random() > 0.5 ? 1 : -1);
  ballDY = -4 * scale;
  score = 0; lives = 3; gameOver = false; won = false;
  bricks = [];
  for (let r = 0; r < brickRows; r++) {
    bricks[r] = [];
    for (let c = 0; c < brickCols; c++) {
      bricks[r][c] = { x: 0, y: 0, alive: true };
    }
  }
}

function drawBricks() {
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const b = bricks[r][c];
      if (!b.alive) continue;
      b.x = brickOffsetLeft + c * (brickW + brickPad);
      b.y = brickOffsetTop + r * (brickH + brickPad);
      ctx.fillStyle = ACCENT;
      ctx.fillRect(b.x, b.y, brickW, brickH);
    }
  }
}

function drawPaddle() {
  ctx.fillStyle = ACCENT;
  ctx.fillRect(paddleX, paddleY, paddleW, paddleH);
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(ballX, ballY, ballR, 0, Math.PI * 2);
  ctx.fillStyle = ACCENT;
  ctx.fill();
  ctx.closePath();
}

function drawHUD() {
  ctx.fillStyle = ACCENT;
  ctx.font = `${14 * scale}px sans-serif`;
  ctx.fillText(`Score: ${score}`, 10, 24 * scale);
  ctx.fillText(`Lives: ${lives}`, W - 80 * scale, 24 * scale);
}

function drawMessage(msg) {
  ctx.fillStyle = ACCENT;
  ctx.font = `bold ${28 * scale}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(msg, W / 2, H / 2);
  ctx.font = `${16 * scale}px sans-serif`;
  ctx.fillText('Tap or click to restart', W / 2, H / 2 + 36 * scale);
  ctx.textAlign = 'left';
}

function collisionDetection() {
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const b = bricks[r][c];
      if (!b.alive) continue;
      if (ballX > b.x && ballX < b.x + brickW && ballY - ballR < b.y + brickH && ballY + ballR > b.y) {
        ballDY = -ballDY;
        b.alive = false;
        score++;
        if (score === brickRows * brickCols) { won = true; gameOver = true; }
      }
    }
  }
}

function update() {
  if (gameOver) return;
  ballX += ballDX;
  ballY += ballDY;
  // walls
  if (ballX + ballR > W || ballX - ballR < 0) ballDX = -ballDX;
  if (ballY - ballR < 0) ballDY = -ballDY;
  // paddle
  if (ballY + ballR >= paddleY && ballX > paddleX && ballX < paddleX + paddleW) {
    ballDY = -Math.abs(ballDY);
    let hit = (ballX - paddleX) / paddleW - 0.5;
    ballDX = hit * 6 * scale;
  }
  // bottom
  if (ballY - ballR > H) {
    lives--;
    if (lives <= 0) { gameOver = true; }
    else { ballX = W / 2; ballY = paddleY - ballR - 2; ballDX = 3 * scale * (Math.random() > 0.5 ? 1 : -1); ballDY = -4 * scale; }
  }
  collisionDetection();
}

function draw() {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);
  drawBricks();
  drawPaddle();
  drawBall();
  drawHUD();
  if (gameOver) drawMessage(won ? 'You Win!' : 'Game Over');
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Controls
function movePaddle(x) {
  paddleX = x - paddleW / 2;
  if (paddleX < 0) paddleX = 0;
  if (paddleX + paddleW > W) paddleX = W - paddleW;
}
canvas.addEventListener('mousemove', e => movePaddle(e.clientX));
canvas.addEventListener('touchmove', e => { e.preventDefault(); movePaddle(e.touches[0].clientX); }, { passive: false });
canvas.addEventListener('click', () => { if (gameOver) initGame(); });
canvas.addEventListener('touchend', () => { if (gameOver) initGame(); });
window.addEventListener('resize', resize);

initGame();
loop();
</script>
</body>
</html>
